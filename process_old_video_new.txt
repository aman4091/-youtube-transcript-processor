async function processOldVideo(video: any, settings: any, supabase: any) {
  try {
    const videoUrl = `https://www.youtube.com/watch?v=${video.video_id}`;
    const transcript = await fetchTranscriptWithRotation(videoUrl, settings);
    console.log(`Transcript fetched: ${transcript.length} chars`);

    const chunks = chunkText(transcript, 7000);
    const totalChunks = chunks.length;
    console.log(`Split into ${totalChunks} chunks`);

    const existingResults = video.chunk_results || [];
    const completedIndices = new Set(existingResults.map((r: any) => r.index));
    console.log(`üì¶ Found ${existingResults.length} previously completed chunks`);
    console.log(`üöÄ Processing ${totalChunks - existingResults.length} NEW chunks!`);

    await supabase.from('scheduled_videos').update({ total_chunks: totalChunks }).eq('id', video.id);

    const chunkPromises = chunks.map(async (chunk, i) => {
      if (completedIndices.has(i)) {
        console.log(`‚è≠Ô∏è [${i + 1}/${totalChunks}] Skipping (already done)`);
        const existing = existingResults.find((r: any) => r.index === i);
        return { index: i, content: existing.content, status: 'skipped' };
      }

      console.log(`[${i + 1}/${totalChunks}] Starting...`);

      const chunkPrompt = settings.custom_prompt || 'Process this transcript:';
      const fullPrompt = totalChunks > 1 ? `${chunkPrompt}\n\n[Part ${i + 1} of ${totalChunks}]` : chunkPrompt;

      const processingPromise = (async () => {
        let aiResult;
        if (settings.ai_model === 'deepseek') {
          aiResult = await processWithDeepSeek(fullPrompt, chunk, settings.deepseek_api_key);
        } else {
          aiResult = await processWithGeminiFlash(fullPrompt, chunk, settings.gemini_api_key);
        }
        if (aiResult.error) throw new Error(aiResult.error);
        console.log(`‚úÖ [${i + 1}] Done (${aiResult.content.length} chars)`);
        return { index: i, content: aiResult.content };
      })();

      try {
        const result = await processChunkWithTimeout(processingPromise);
        return { ...result, status: 'fulfilled' };
      } catch (error: any) {
        console.error(`‚ùå [${i + 1}] FAILED:`, error.message);
        return { index: i, error: error.message, status: 'rejected' };
      }
    });

    console.log(`‚è≥ Waiting for chunks (60s timeout per chunk)...`);
    const startTime = Date.now();
    const results = await Promise.allSettled(chunkPromises);
    const processingTime = ((Date.now() - startTime) / 1000).toFixed(2);

    const successfulChunks: any[] = [];
    const failedChunks: number[] = [];

    results.forEach((result) => {
      if (result.status === 'fulfilled') {
        const chunkData = result.value;
        if (chunkData.status === 'fulfilled' || chunkData.status === 'skipped') {
          successfulChunks.push({ index: chunkData.index, content: chunkData.content, processed_at: new Date().toISOString() });
        } else if (chunkData.status === 'rejected') {
          failedChunks.push(chunkData.index);
        }
      }
    });

    const allChunkResults = [...existingResults.filter((r: any) => !successfulChunks.find(s => s.index === r.index)), ...successfulChunks];
    const completedCount = allChunkResults.length;

    console.log(`‚úÖ New: ${successfulChunks.length - existingResults.length} | ‚ùå Failed: ${failedChunks.length} | Total: ${completedCount}/${totalChunks} | Time: ${processingTime}s`);

    await supabase.from('scheduled_videos').update({ chunk_results: allChunkResults, completed_chunks: completedCount, failed_chunks: failedChunks }).eq('id', video.id);

    if (completedCount === totalChunks) {
      const sortedResults = allChunkResults.sort((a: any, b: any) => a.index - b.index);
      const finalScript = sortedResults.map((r: any) => r.content).join('\n\n');
      console.log(`üéâ ALL COMPLETE! Script: ${finalScript.length} chars`);
      return { success: true, totalChunks, completedChunks: completedCount };
    } else {
      console.log(`‚ö†Ô∏è Partial (${completedCount}/${totalChunks}) - will resume next run`);
      return { success: false, partialSuccess: true, totalChunks, completedChunks: completedCount, error: `${failedChunks.length} chunks failed` };
    }
  } catch (error: any) {
    return { success: false, error: error.message };
  }
}
